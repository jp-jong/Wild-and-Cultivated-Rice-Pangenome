import pandas as pd
import re
import os
import argparse

"""

Use the biallelic SV output from script 0x_get_bialsv.py. This script processes each of the bubble files generated by
minigraph --call and traces the path of each assemble through the bubbles. It reads a directory with a strict file name syntax {asm}.alleles.bed and {asm} becomes the name of
this file inside a temporary dictionary. 

"""



# process biallelic file

"""
Sample line for biallelic file
chr01 11397713 11397713 Insertion 0 66 s5880 0 s236821 s5881

Ranks of each possible bubble node path is determined based on previous script's output. In columns 'source','refNode','nonrefNode','sink',
if bubble node is in refNode, the path through this bubble is tagged as a reference path. Otherwise, it is a nonreference/alternative path. 
Two new columns are added which are refAsms and altAsms. These are placeholders for name of the assemblies that traverses these paths. 
"""

def process_biallelic(biallelic_file):
    biallelic_df = pd.read_csv(biallelic_file, sep=' ', header=None, 
                               names=['chr','start','end','type','refLen','nonrefLen','source','refNode','nonrefNode','sink'])
    new_df = biallelic_df[['chr','start','end','type','refLen','nonrefLen']].copy()
    
    new_df['refPath'] = biallelic_df.apply(lambda row: 
        f"{row['source']},{row['refNode']},{row['sink']}" if row['refNode'] != '0' 
        else f"{row['source']},{row['sink']}", axis=1)
    
    new_df['altPath'] = biallelic_df.apply(lambda row: 
        f"{row['source']},{row['nonrefNode']},{row['sink']}" if row['nonrefNode'] != '0' 
        else f"{row['source']},{row['sink']}", axis=1)
    
    new_df['refAsms'] = ''
    new_df['altAsms'] = ''
    
    return new_df

# process {asm}.alleles.bed file

"""
clean_node, parse_info, and clean_bubble are helper functions to clean the lines of the input bubble files. 

Sample {asm}.alleles.bed
id=Nipponbare|chr01 11237249    11237250    >s5821  >s5823  >s5822:1:+:chr01:11237241:11237255

-clean_node cleans the ">" "<" to prepare the node combinations for path matching in biallelic_sv file
-parse_info takes the last column which is named info to split the entries and take the bubble nodes ID and the length of the node. 
Note that not all assemblies traverses bubbles. In minigraph --bubble output, they are usually represented by simple "." 
-clean_bubble is uses parse_info to finalize the dataframe output. It cleans the ID to ready the file for bedtool intersections. 
"""

def clean_node(node):
    return re.sub(r'[<>]','', node)

def parse_info(info):
    parts = info.split(':')
    if len(parts) < 2:
        return None, None    
    nodes = tuple(clean_node(node) for node in re.findall(r'[<>]?s\d+', parts[0]))
    length = int(parts[1])
    
    return nodes, length

def clean_bubble(bubble_file):
    bubble_df = pd.read_csv(bubble_file, sep='\t', header=None, 
                            names=['chr','start','end','source','sink','info'])
    bubble_df['chr'] = bubble_df['chr'].str.split('|').str[1] 
    
    parsed_info = bubble_df['info'].apply(parse_info)
    bubble_df['node'] = parsed_info.apply(lambda x: x[0] if x is not None else None)
    bubble_df['len'] = parsed_info.apply(lambda x: x[1] if x is not None else None)

    return bubble_df

"""
Main function to process biallelic_sv and the bubble files. 

It processes the biallelic df and merges the bubble files to keep the common lines. This is an important step. 
Then, it parses the path in the biallelic_df for matching. If paths from an assembly matches the biallelic_sv paths, 
they are either assigned to the ref or alt path depending on the length and node traversals. See previous conditions. 
All leading "," are then stripped for cleanup.
"""

def merge_and_update_asms(biallelic_df, bubbles_dict):
    biallelic_df = process_biallelic(biallelic_df)
    
    def parse_path(path):
        return tuple(clean_node(node.strip()) for node in path.split(','))

    for asm, bubble_file in bubbles_dict.items():
        bubble_df = clean_bubble(bubble_file)
        temp_df = pd.merge(biallelic_df, bubble_df, on=['chr','start','end'], suffixes=('_x','_y'))

        temp_dict = {}
        for _, row in temp_df.iterrows():
            if row['node'] is None or row['len'] is None:
                continue

            ref_path = parse_path(row['refPath'])
            alt_path = parse_path(row['altPath'])
            y_path = (clean_node(row['source']),) + row['node'] + (clean_node(row['sink']),)

            if y_path == ref_path and row['len'] == row['refLen']:
                temp_dict.setdefault(row.name, {'refAsms': '', 'altAsms': ''})['refAsms'] = asm

            if y_path == alt_path and row['len'] == row['nonrefLen']:
                temp_dict.setdefault(row.name, {'refAsms': '', 'altAsms':''})['altAsms'] = asm

        for index, asms in temp_dict.items():
            if asms['refAsms']:
                biallelic_df.at[index, 'refAsms'] = f"{biallelic_df.at[index, 'refAsms']},{asms['refAsms']}" if biallelic_df.at[index, 'refAsms'] else asms['refAsms']
            if asms['altAsms']:
                biallelic_df.at[index, 'altAsms'] = f"{biallelic_df.at[index, 'altAsms']},{asms['altAsms']}" if biallelic_df.at[index, 'altAsms'] else asms['altAsms']

    biallelic_df['refAsms'] = biallelic_df['refAsms'].str.rstrip(',')
    biallelic_df['altAsms'] = biallelic_df['altAsms'].str.rstrip(',')

    # Handle empty entries
    biallelic_df['refAsms'] = biallelic_df['refAsms'].fillna('').replace('', 'noassemb')
    biallelic_df['altAsms'] = biallelic_df['altAsms'].fillna('').replace('', 'noassemb')

    return biallelic_df

def main():
    parser = argparse.ArgumentParser(description='Process biallelic files and alleles.bed files.')
    parser.add_argument('-b','--biallelic_file', help='Path to the biallelic file')
    parser.add_argument('-a','--alleles_dir', help='Directory containing alleles.bed files')
    parser.add_argument('-o','--output_file', help='Path to the output file')

    args = parser.parse_args()

    # Create bubbles_dict from alleles.bed files in the specified directory
    bubbles_dict = {}
    for filename in os.listdir(args.alleles_dir):
        if filename.endswith('.alleles.bed'):
            asm_name = filename.split('.')[0]  # Extract assembly name
            file_path = os.path.join(args.alleles_dir, filename)
            bubbles_dict[asm_name] = file_path

    result = merge_and_update_asms(args.biallelic_file, bubbles_dict)
    result.to_csv(args.output_file, sep='\t', index=False)
    print(f"Results saved to {args.output_file}")

if __name__ == "__main__":
    main()